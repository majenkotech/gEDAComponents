#!/usr/bin/php
<?php

$file = @$argv[1];
if (!$file) {
    print("Usage: ele2png <gEDA Element File>\n");
    exit(10);
}

if (!file_exists($file)) {
    print("File not found: $file\n");
    exit(10);
}

if (preg_match("/^(.*)\.fp$/", $file, $m)) {
    $out = $m[1] . ".png";
} else {
    print("Not a footprint file: $file\n");
    exit(10);
}

class pad {
    public $x1;
    public $y1;
    public $x2;
    public $y2;
    public $width;
    public $clear;
    public $mask;
    public $paste;
    public $flags;
}

class pin {
    public $x;
    public $y;
    public $drill;
    public $clear;
    public $annular;
    public $flags;
}

class line {
    public $x1;
    public $y1;
    public $x2;
    public $y2;
    public $width;
    public $flags;
}

function parseSize($size) {
    if (preg_match("/^([-\d\.]+)mm$/", $size, $m)) {
        return $m[1];
    }
    if (preg_match("/^([-\d\.]+)mil$/", $size, $m)) {
        return $m[1] * 0.0254;
    }
    return 0;
}

function ImageRectangleWithRoundedCorners(&$im, $x1, $y1, $x2, $y2, $radius, $color)
{
    // draw rectangle without corners
    imagefilledrectangle($im, $x1+$radius, $y1, $x2-$radius, $y2, $color);
    imagefilledrectangle($im, $x1, $y1+$radius, $x2, $y2-$radius, $color);
    // draw circled corners
    imagefilledellipse($im, $x1+$radius, $y1+$radius, $radius*2, $radius*2, $color);
    imagefilledellipse($im, $x2-$radius, $y1+$radius, $radius*2, $radius*2, $color);
    imagefilledellipse($im, $x1+$radius, $y2-$radius, $radius*2, $radius*2, $color);
    imagefilledellipse($im, $x2-$radius, $y2-$radius, $radius*2, $radius*2, $color);
}

$pads = array();
$pins = array();
$lines = array();

$data = file_get_contents($file);
$datalines = explode("\n", $data);

$square = 1;

foreach ($datalines as $line) {
    $line = trim($line);

    if (preg_match("/^([a-zA-Z]+)\s*[\[\(](.*)[\]\)]$/", $line, $m)) {
        $type = $m[1];
        $data = explode(" ", $m[2]);
        //print("Type: $type\n");

        if ($type == "Pad") {
            $p = new pad;
            $p->x1 = parseSize($data[0]);
            $p->y1 = parseSize($data[1]);
            $p->x2 = parseSize($data[2]);
            $p->y2 = parseSize($data[3]);
            $p->width = parseSize($data[4]);
            $p->clear = parseSize($data[5]);
            $p->mask = parseSize($data[6]);
            $p->flags = 0;
            if (count($data) == 11) { // Has solder paste
                $p->paste = parseSize($data[7]);
                if (preg_match("/square/", $data[10], $m)) {
                    $p->flags |= $square;
                }
            } else {
                if (preg_match("/square/", $data[9], $m)) {
                    $p->flags |= $square;
                }
                $p->paste = $p->mask;
            }
            // Todo: add flags
            $pads[] = $p;
        }

        if ($type == "ElementLine") {
            $l = new line;
            $l->x1 = parseSize($data[0]);
            $l->y1 = parseSize($data[1]);
            $l->x2 = parseSize($data[2]);
            $l->y2 = parseSize($data[3]);
            $l->width = parseSize($data[4]);
            $flags = 0;
            $lines[] = $l;
        }

        // Todo: add pins.
            
    }
}

$minx = 9999999;
$miny = 9999999;
$maxx = -9999999;
$maxy = -9999999;

foreach ($lines as $line) {
    $x1a = $line->x1 - $line->width / 2;
    $y1a = $line->y1 - $line->width / 2;
    $x2a = $line->x2 - $line->width / 2;
    $y2a = $line->y2 - $line->width / 2;
    $x1b = $line->x1 + $line->width / 2;
    $y1b = $line->y1 + $line->width / 2;
    $x2b = $line->x2 + $line->width / 2;
    $y2b = $line->y2 + $line->width / 2;

    $minx = min($minx, $x1a, $x1b, $x2a, $x2b);
    $miny = min($miny, $y1a, $y1b, $y2a, $y2b);
    $maxx = max($maxx, $x1a, $x1b, $x2a, $x2b);
    $maxy = max($maxy, $y1a, $y1b, $y2a, $y2b);

}

foreach ($pads as $pad) {
    $x1a = $pad->x1 - $pad->width / 2;
    $y1a = $pad->y1 - $pad->width / 2;
    $x2a = $pad->x2 - $pad->width / 2;
    $y2a = $pad->y2 - $pad->width / 2;
    $x1b = $pad->x1 + $pad->width / 2;
    $y1b = $pad->y1 + $pad->width / 2;
    $x2b = $pad->x2 + $pad->width / 2;
    $y2b = $pad->y2 + $pad->width / 2;
    $x1c = $pad->x1 - $pad->width / 2 - $pad->clear;
    $y1c = $pad->y1 - $pad->width / 2 - $pad->clear;
    $x2c = $pad->x2 - $pad->width / 2 - $pad->clear;
    $y2c = $pad->y2 - $pad->width / 2 - $pad->clear;
    $x1d = $pad->x1 + $pad->width / 2 + $pad->clear;
    $y1d = $pad->y1 + $pad->width / 2 + $pad->clear;
    $x2d = $pad->x2 + $pad->width / 2 + $pad->clear;
    $y2d = $pad->y2 + $pad->width / 2 + $pad->clear;
    $x1e = $pad->x1 - $pad->mask / 2;
    $y1e = $pad->y1 - $pad->mask / 2;
    $x2e = $pad->x2 - $pad->mask / 2;
    $y2e = $pad->y2 - $pad->mask / 2;
    $x1f = $pad->x1 + $pad->mask / 2;
    $y1f = $pad->y1 + $pad->mask / 2;
    $x2f = $pad->x2 + $pad->mask / 2;
    $y2f = $pad->y2 + $pad->mask / 2;
    $x1g = $pad->x1 - $pad->paste / 2;
    $y1g = $pad->y1 - $pad->paste / 2;
    $x2g = $pad->x2 - $pad->paste / 2;
    $y2g = $pad->y2 - $pad->paste / 2;
    $x1h = $pad->x1 + $pad->paste / 2;
    $y1h = $pad->y1 + $pad->paste / 2;
    $x2h = $pad->x2 + $pad->paste / 2;
    $y2h = $pad->y2 + $pad->paste / 2;

    $minx = min($minx, $x1a, $x1b, $x1c, $x1d, $x1e, $x1f, $x1g, $x1h,
                       $x2a, $x2b, $x2c, $x2d, $x2e, $x2f, $x2g, $x2h);
    $miny = min($miny, $y1a, $y1b, $y1c, $y1d, $y1e, $y1f, $y1g, $y1h,
                       $y2a, $y2b, $y2c, $y2d, $y2e, $y2f, $y2g, $y2h);
    $maxx = max($maxx, $x1a, $x1b, $x1c, $x1d, $x1e, $x1f, $x1g, $x1h,
                       $x2a, $x2b, $x2c, $x2d, $x2e, $x2f, $x2g, $x2h);
    $maxy = max($maxy, $y1a, $y1b, $y1c, $y1d, $y1e, $y1f, $y1g, $y1h,
                       $y2a, $y2b, $y2c, $y2d, $y2e, $y2f, $y2g, $y2h);

}

// Todo: add pins.

$minx *= 1.1;
$miny *= 1.1;
$maxx *= 1.1;
$maxy *= 1.1;

$width = $maxx - $minx;
$height = $maxy - $miny;

$offx = $minx;
$offy = $miny;

print "Dimensions: $width x $height\n";
print "Offset: $offx x $offy\n";

$scale = 100;

$copperLayer = ImageCreateTrueColor($width * $scale, $height * $scale);
$maskLayer = ImageCreateTrueColor($width * $scale, $height * $scale);
$pasteLayer = ImageCreateTrueColor($width * $scale, $height * $scale);

ImageAlphaBlending($copperLayer, false);
ImageAlphaBlending($maskLayer, false);
ImageAlphaBlending($pasteLayer, false);

$copper = ImageColorAllocate($copperLayer, 255, 0, 0);
$substrate = ImageColorAllocate($copperLayer, 0, 0, 0);
$enig = ImageColorAllocate($copperLayer, 255, 215, 0);
$mask = ImageColorAllocateAlpha($maskLayer, 255, 0, 0, 64);
$hole = ImageColorAllocateAlpha($maskLayer, 0, 0, 0, 127);
$paste = ImageColorAllocate($pasteLayer, 100, 100, 100);
$nopaste = ImageColorAllocateAlpha($pasteLayer, 0, 0, 0, 127);
$silk = ImageColorAllocate($copperLayer, 255, 255, 255);

ImageFilledRectangle($copperLayer, 0, 0, $width * $scale, $height * $scale, $copper);
ImageFilledRectangle($maskLayer, 0, 0, $width * $scale, $height * $scale, $mask);
ImageFilledRectangle($pasteLayer, 0, 0, $width * $scale, $height * $scale, $nopaste);

function swap(&$a, &$b) {
    $c = $a;
    $a = $b;
    $b = $c;
}

function interpolateLine(&$img, $x0, $y0, $x1, $y1, $width, $round, $color) {
    $steep = abs($y1 - $y0) > abs($x1 - $x0);
    if ($steep) {
        swap($x0, $y0);
        swap($x1, $y1);
    }

    if ($x0 > $x1) {
        swap($x0, $x1);
        swap($y0, $y1);
    }

    $dx = $x1 - $x0;
    $dy = abs($y1 - $y0);

    $err = $dx / 2;

    if ($y0 < $y1) {
        $ystep = 1;
    } else {
        $ystep = -1;
    }

    for (; $x0<=$x1; $x0++) {
        if ($steep) {
            if ($round) {
                ImageFilledEllipse($img, $y0, $x0, $width, $width, $color);
            } else {
                ImageFilledRectangle($img, 
                    $y0 - $width/2, $x0 - $width/2, 
                    $y0 + $width/2, $x0 + $width/2, 
                    $color);
            }
        } else {
            if ($round) {
                ImageFilledEllipse($img, $x0, $y0, $width, $width, $color);
            } else {
                ImageFilledRectangle($img, 
                    $x0 - $width/2, $y0 - $width/2, 
                    $x0 + $width/2, $y0 + $width/2, 
                    $color);
            }
        }
        $err -= $dy;
        if ($err < 0) {
            $y0 += $ystep;
            $err += $dx;
        }
    }

}

function drawLine(&$img, &$ob, $width, $color) {
    global $scale;
    global $offx;
    global $offy;
    global $square;

    $round = !($ob->flags & $square);
    interpolateLine($img, 
        ($ob->x1 - $offx) * $scale, 
        ($ob->y1 - $offy) * $scale, 
        ($ob->x2 - $offx) * $scale, 
        ($ob->y2 - $offy) * $scale, 
        $width * $scale, $round, $color);
}

foreach ($pads as $pad) {
    drawLine($copperLayer, $pad, $pad->width + $pad->clear, $substrate);
}

foreach ($pads as $pad) {
    drawLine($copperLayer, $pad, $pad->width, $enig);
}

foreach ($pads as $pad) {
    // Punch a hole in the mask
    drawLine($maskLayer, $pad, $pad->mask, $hole);
}

foreach ($pads as $pad) {
    drawLine($pasteLayer, $pad, $pad->paste, $paste);
}

ImageAlphaBlending($copperLayer, true);
ImageAlphaBlending($maskLayer, true);
ImageAlphaBlending($pasteLayer, true);
ImageCopy($copperLayer, $maskLayer, 0, 0, 0, 0, $width * $scale, $height * $scale);
ImageCopy($copperLayer, $pasteLayer, 0, 0, 0, 0, $width * $scale, $height * $scale);

foreach ($lines as $line) {
    drawLine($copperLayer, $line, $line->width, $silk);
}


ImageSaveAlpha($copperLayer, true);

ImagePNG($copperLayer, $out); // Todo: craft filename from footprint file name
